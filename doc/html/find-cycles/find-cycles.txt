-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/michaeljklein/find-cycles#readme</a>
@package find-cycles
@version 0.1.0.0

module Data.Cycle

module Data.Cycle.Find

-- | Get the initial state from the first element of a <a>Foldable</a> or
--   return <a>Nothing</a>
foldl1Maybe :: Foldable t => (b -> a -> b) -> (a -> b) -> t a -> Maybe b

-- | Goal:
--   
--   <pre>
--   Goal:
--     Given a list, function, series, etc.
--     1. If there exists xs /= input | and (zipWith (==) (cycle xs) input)
--        Output the shortest, else Nothing.
--     2. If there exists xs | exists (0 &lt;= n) | and (zipWith (==) (cycle xs) (drop n input) &amp;&amp; n + 2 * length xs &lt;= length input
--        (i.e. it eventually cycles, and the cycle repeats fully at least once)
--        Output the shortest, else Nothing.
--   
--   - If we end at anything other than a single value repeated, we recurse.
--   
--   So:
--     Single value repeated n times
--     Values repeated some number of times, recursed on their cycles
--   
--   Ahh!
--     I was thinking we didn't need to store the entire previous list, we don't!
--       We should just store a seq for the current cycle, since fast cons and fast single-element rotation.
--   
--   When a cycle ends, if there were no previous non-equal values, then we'll need to recurse.
--   
--   - If we keep a current-label state and add a label to each value, all value sets after the first will be a range [0..n]
--     * Since the value sets are monotonically decreasing in size, we can use a single allocation to represent all of the maps
--   </pre>
goal :: ()

-- | A representation of a finite cycle (the list should never be infinite)
data Cycle a
Cycle :: Int -> [a] -> Cycle a
[cycleLen] :: Cycle a -> Int
[cycleSeries] :: Cycle a -> [a]
data Cyclic a
Cyclic :: Int -> Cycle a -> Cyclic a
[cyclicLen] :: Cyclic a -> Int
[cyclicCycle] :: Cyclic a -> Cycle a

-- | <a>Just</a> the cycle that makes up the input or <a>Nothing</a>
--   
--   <pre>
--   cyclic (take _ $ cycle xs) = Just xs
--   cyclic _ = Nothing
--   </pre>
cyclic :: Ord a => [a] -> Maybe [a]

-- | <a>Just</a> if the predicate returns <a>True</a>
boolMaybe :: (a -> Bool) -> a -> Maybe a

-- | Is the second list a cycle of the first?
isCycleOf :: Eq a => [a] -> [a] -> Bool

-- | (have we reached two cycles?, value)
twoCycles :: [a] -> [(Bool, a)]

-- | Indexed differences between locations of an element
indexDiffs :: Ord a => [a] -> Map a (Int, [Int])

-- | <a>indexDiffs</a> specialized to <a>Int</a>
intIndexDiffs :: [Int] -> IntMap (Indexed [Int])

-- | The indices of a value in a list
indices :: Eq a => a -> [a] -> [Int]

-- | An <a>Int</a>-indexed value
data Indexed a
Indexed :: {-# UNPACK #-} !Int -> a -> Indexed a
[indexOf] :: Indexed a -> {-# UNPACK #-} !Int
[indexed] :: Indexed a -> a

-- | <a>uncurry</a> for <a>Indexed</a>
uncurryi :: (Int -> a -> b) -> Indexed a -> b

-- | <a>curry</a> for <a>Indexed</a>
curryi :: (Indexed a -> b) -> Int -> a -> b
instance GHC.Base.Functor Data.Cycle.Find.Indexed
instance GHC.Read.Read a => GHC.Read.Read (Data.Cycle.Find.Indexed a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Cycle.Find.Indexed a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Cycle.Find.Indexed a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Cycle.Find.Indexed a)
instance Data.Foldable.Foldable Data.Cycle.Find.Indexed
instance Data.Traversable.Traversable Data.Cycle.Find.Indexed


-- | It's an interesting idea, but I don't really have much of a use for
--   compact finite stacks forming n-ary trees using <tt>MVector</tt>'s.
module Data.FiniteStack

module Data.List.Utils
diff :: Num a => [a] -> [a]

-- | For a monotonically increasing function/series, only output new
--   records.
--   
--   E.g.
--   
--   <pre>
--   monoRecordsOn id [1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,3] = [1,2,3]
--   </pre>
monoRecordsOn :: Eq b => (a -> b) -> [a] -> [a]

-- | Is the list <a>eventually1s</a> or <a>eventually01s</a>, and
--   <a>True</a> if <a>eventually1s</a>
eventually101 :: [Int] -> (Bool, [Int], Int)

-- | The number of elements of the list ending in <tt>0, 1, 0, 1..</tt> and
--   the rest of the list
eventually01s :: [Int] -> ([Int], Int)

-- | The number of elements of the list ending in <tt>1, 1, 1, 1..</tt> and
--   the rest of the list
eventually1s :: [Int] -> ([Int], Int)

-- | Count the number of elements in the prefix satisfying the predicate
--   and return the rest of the list
countPrefixOf :: (a -> Bool) -> [a] -> (Int, [a])

-- | Test <a>countPrefixOf</a>
testCountPrefixOf :: Int -> Int -> Bool

-- | Count the number of elements in the suffix satisfying the predicate
--   and return the rest of the list
countSuffixOf :: (a -> Bool) -> [a] -> ([a], Int)

-- | Test <a>countSuffixOf</a>
testCountSuffixOf :: Int -> Int -> Bool
middleOne :: Int -> Int -> [Int]

-- | Return the length of the run and the element. For example:
--   
--   <pre>
--   位&gt; <a>runs</a> [1,1,2,3,3,3]
--   [(2,1),(1,2),(3,3)]
--   </pre>
runs :: Eq a => [a] -> [(Int, a)]

-- | Tally a <a>Foldable</a> of an <a>Ord</a>
tallyOrd :: (Foldable t, Ord a) => t a -> Map a Int

-- | Tally a <a>Foldable</a> of <a>Int</a>s
tally :: Foldable t => t Int -> IntMap Int

-- | Tally <a>Maxes</a> of <a>Int</a>s
tallyMaxes :: Foldable t => t (Maxes Int) -> IntMap Int

-- | Convert <tt>x</tt> to base <tt>b</tt>
toBase :: Integral a => a -> a -> [a]

-- | Convert a base-<tt>b</tt> list of digits to a <a>Num</a>
fromBase :: Num a => a -> [a] -> a

-- | Given the number of values, the index of the rotation, and a value to
--   permute (by cycling), perform the permutation.
--   
--   位&gt; simplePerm 5 0 <a>$</a> [1..5] [1,2,3,4,5]
--   
--   位&gt; simplePerm 5 1 <a>$</a> [1..5] [2,3,4,5,1]
--   
--   位&gt; simplePerm 5 2 <a>$</a> [1..5] [3,4,5,1,2]
simplePerm :: Integral a => a -> a -> a -> a

-- | Assert each in list and throw an error with the index if any
--   <a>False</a>
asserts :: [Bool] -> IO ()

-- | <a>diff</a> until the list is anywhere decreasing
diffUntilDec :: (Num a, Ord a) => [a] -> [a]
binTransform :: Num a => [a] -> [a]

-- | <a>binTransform</a> <tt>n</tt> times
binTransformN :: Num a => [a] -> Int -> [a]

-- | Alternate version of <a>binTransform</a>
btrans :: [Int] -> [Int]

-- | Alternate version of inverse of <a>binTransform</a>
invBtrans :: [Int] -> [Int]

-- | Count the number of elements satisfying the predicate
count :: Foldable t => (a -> Bool) -> t a -> Int

-- | Map even indices
mapEvens :: (a -> a) -> [a] -> [a]

-- | Map odd indices
mapOdds :: (a -> a) -> [a] -> [a]

-- | parityMap f g = mapEvens f . mapOdds g = mapOdds g . mapEvens f
parityMap :: (a -> a) -> (a -> a) -> [a] -> [a]

-- | Even-index elements
evens :: [a] -> [a]

-- | Odd-index elements
odds :: [a] -> [a]

-- | Apply the function the given number of times
nest :: (Ord t1, Num t1) => t1 -> t2 -> t2 -> t2 -> t2

-- | Sums of successive pairs of elements
sums :: Num a => [a] -> [a]

-- | The maximum, along with the number of times that it has occurred
data Maxes a
Maxes :: !Int -> a -> Maxes a
[numMaxes] :: Maxes a -> !Int
[getMaxes] :: Maxes a -> a

-- | Convert a number to <a>Maxes</a>
maxes :: a -> Maxes a

-- | Convert <a>Maxes</a> to a tuple
unMaxes :: Maxes a -> (Int, a)

-- | Fold at least one element or fail with <a>Nothing</a>. Use that
--   element to build the first <tt>b</tt>.
foldl1Maybe :: Foldable t => (b -> a -> b) -> (a -> b) -> t a -> Maybe b

-- | Time (in seconds) that an action takes (does not account for timing
--   overhead)
timed :: IO () -> IO Double

-- | mapM_ with timing info for each action
mapM_Timed :: (a -> IO ()) -> [a] -> IO ()
instance GHC.Base.Functor Data.List.Utils.Maxes
instance GHC.Show.Show a => GHC.Show.Show (Data.List.Utils.Maxes a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.List.Utils.Maxes a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.List.Utils.Maxes a)
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.List.Utils.Maxes a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.List.Utils.Maxes a)
instance (GHC.Classes.Ord a, GHC.Enum.Bounded a) => GHC.Base.Monoid (Data.List.Utils.Maxes a)

module Data.Map.Utils

-- | Insert into or update a <a>Map</a>
upsert :: Ord k => a -> (a -> a) -> k -> Map k a -> Map k a

-- | Insert into or update an <a>IntMap</a>
intUpsert :: a -> (a -> a) -> Int -> IntMap a -> IntMap a

-- | Convert a <a>Map</a> to an <a>IntMap</a>
mapToIntMap :: Enum k => Map k a -> IntMap a

-- | Convert an <a>IntMap</a> to an <a>Map</a>
intMapToMap :: Enum k => IntMap a -> Map k a

-- | Lazily match on <a>Bin</a>
unsafeFromSingleton :: Map k a -> (k, a)
foldMapWithKey1 :: Semigroup b => (k -> a -> b) -> Map k a -> b
foldIntMapWithKey1 :: Semigroup b => (Key -> a -> b) -> IntMap a -> b

module Data.Pair

-- | A lazy pair of values
newtype Pair a
Pair :: (a, a) -> Pair a
[getPair] :: Pair a -> (a, a)
instance GHC.Base.Functor Data.Pair.Pair
instance Data.Functor.Classes.Eq1 Data.Pair.Pair
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Pair.Pair a)
instance Data.Functor.Classes.Ord1 Data.Pair.Pair
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Pair.Pair a)
instance Data.Functor.Classes.Show1 Data.Pair.Pair
instance GHC.Show.Show a => GHC.Show.Show (Data.Pair.Pair a)
instance Data.Functor.Classes.Read1 Data.Pair.Pair
instance GHC.Read.Read a => GHC.Read.Read (Data.Pair.Pair a)
instance GHC.Base.Applicative Data.Pair.Pair

module Data.BStream

-- | Infinite complete binary trees
newtype BStream a
BStream :: Cofree Pair a -> BStream a
[runBStream] :: BStream a -> Cofree Pair a

-- | <tt><tt>paths</tt> <a>bools</a></tt> is the list of all infinite
--   binary sequences. Well, kind of.. it'a really just <tt><a>repeat</a>
--   <a>False</a></tt>, but if we could complete collecting infinite series
--   in finite time, we could list them all.
bools :: Pair (BStream Bool)

-- | Scan along the results of a <a>BStream</a> with a <a>Semigroup</a> and
--   a method to convert to it.
scanMap :: Semigroup s => (a -> s) -> BStream a -> BStream s

-- | Use a map and step to scan a <a>BStream</a>
stepMap :: (a -> b -> b) -> (a -> b) -> BStream a -> BStream b

-- | All levels of a <a>BStream</a> (infinite)
blevels :: BStream a -> [[a]]

-- | The <tt>n</tt>-th level of a <a>BStream</a>
blevelN :: Int -> BStream a -> [a]
instance GHC.Base.Functor Data.BStream.BStream
instance Control.Comonad.Cofree.Class.ComonadCofree Data.Pair.Pair Data.BStream.BStream
instance Control.Comonad.Comonad Data.BStream.BStream

module Data.Semigroup.Free

-- | Size notes:
--   
--   <pre>
--   So a single element weighs ~400 bytes.
--     Supposing a MArray has a 1-byte overhead per element,
--     could we get a ~2 byte overhead per element if we stored every 400 elements in a MArray?
--     Ehh.. I don't know if the price of copying arrays will offset the cost..
--   
--   What if we only access one cycle element at a time?
--     In that case, it's probably better to simply carry around a list and cons onto it.
--   
--   What if we have a predictable cycle-size?
--     In that case, it's probably best to use pre-allocated memory
--     Possibly a pool of smaller pre-allocated chunks
--   </pre>
sizeNotes :: ()

-- | Note:
--   
--   <pre>
--   On one hand, it seems nice to preserve the commutativity of the GappedIxCycle's
--   On the other hand, it takes O(min n m) time to zip two GappedIxCycle's together.
--   On the other hand, I'm not sure it needs to be anything other than a []<i>Seq</i>Set of period-1 cycles whose LCM is the given period. (that would give O(1) (&lt;&gt;))
--   </pre>
notes :: ()

-- | <pre>
--   GappedCycle a == Free Pair (Int, a)
--   </pre>
--   
--   data IntGappedCycle where IGCPure :: !Int -&gt; !Int -&gt;
--   IntGappedCycle -- Period, Value IGCMappend :: !IntGappedCycle -&gt;
--   !IntGappedCycle -&gt; IntGappedCycle
--   
--   <a>Alternative</a> without <a>empty</a>
class Applicative f => Semialternative f
(<!>) :: Semialternative f => f a -> f a -> f a
saconcat :: Semialternative f => NonEmpty (f a) -> f a
saconcatMap :: Semialternative f => (a -> f b) -> NonEmpty a -> f b

-- | Wrap a <a>Semialternative</a> to provide a <a>Semigroup</a> instance
newtype WrapSemialternative f a
WrapSemialternative :: f a -> WrapSemialternative f a
[runWrapSemialternative] :: WrapSemialternative f a -> f a

-- | A free <a>Semigroup</a> is a <a>Semialternative</a> that we can
--   <a>foldMap1</a> over (<a>foldMap</a> specialized to non-empty inputs)
--   and convert to any other <a>SemigroupFree</a> (they're all isomorphic
--   to each other).
class Semialternative f => SemigroupFree f
foldMap1 :: (SemigroupFree f, Semigroup s) => (a -> s) -> f a -> s
semigroupFree :: (SemigroupFree f, SemigroupFree g) => f a -> g a

-- | From the triangle benchmakrs, this is the fastest. How fast?
--   <tt>~100x</tt> faster than <a>NonEmpty</a>, taking <tt>~180 ms</tt> to
--   construct and destruct a triangle with around a million elements.
--   
--   For a little comparison, the average human blink of an eye is around
--   <tt>100-400 ms</tt> (according to WolframAlpha). I can process a
--   trangular collection of a million elements in less then half the
--   average time that it takes to blink an eye!
--   
--   That's <tt>~180 ns</tt> per element..
--   
--   My computer has a <tt>3.1 GHz</tt> processor. Assuming total
--   utilization of a single core, we get a cycle-duration of <tt>~0.323
--   ns</tt>. That gives us an estimate of <tt>557</tt> cycles per element.
--   
--   That's not the greatest. I'll have to check CPU utilization for that
--   benchmark to see if it's skewing my quick math. (267.2%?, not sure
--   what to make of that. need to run without criterion to remove
--   overhead) Though it's still not bad for a pure, polymorphic data type.
--   
--   All in all, this data type is plenty fast for its primary purpose:
--   quickly accumulating cycle-pieces when calculating the final cycle.
data FreeSemigroup a
[PureFreeSemigroup] :: a -> FreeSemigroup a
[AppendFreeSemigroup] :: FreeSemigroup a -> FreeSemigroup a -> FreeSemigroup a

-- | <a>semigroupFree</a> specialized to <a>FreeSemigroup</a>
toFreeSemigroup :: SemigroupFree f => f a -> FreeSemigroup a

-- | It looks like this sucks around the [2^12..2^16] elements range
data FreeSemigroup' a
[PureFreeSemigroup'] :: !a -> FreeSemigroup' a
[AppendFreeSemigroup'] :: !(FreeSemigroup' a) -> !(FreeSemigroup' a) -> FreeSemigroup' a

-- | <a>Free</a>-based <a>FreeSemigroup</a>
newtype FreePS a
FreePS :: Free Pair a -> FreePS a
[runFreePS] :: FreePS a -> Free Pair a

-- | <a>F</a>-based <a>FreeSemigroup</a>
newtype FPS a
FPS :: F Pair a -> FPS a
[runFPS] :: FPS a -> F Pair a

-- | Partially applied <a>foldMap1</a> wrapped in a <tt>newtype</tt>.
newtype FSemigroup a
FSemigroup :: forall s. Semigroup s => (a -> s) -> s -> FSemigroup a
[runFSemigroup] :: FSemigroup a -> forall s. Semigroup s => (a -> s) -> s

-- | <a>FSemigroup</a> with explicitly provided <tt>(<a>&lt;&gt;</a>)</tt>.
--   
--   Slightly faster in triangle benchmarks.
newtype FS a
FS :: forall s. (s -> s -> s) -> (a -> s) -> s -> FS a
[runFS] :: FS a -> forall s. (s -> s -> s) -> (a -> s) -> s

-- | Lift function application to strict function application
liftS2 :: (a -> b -> c) -> a -> b -> c

-- | Strict <a>FSemigroup</a> with explicitly provided
--   <tt>(<a>&lt;&gt;</a>)</tt>.
newtype FS' a
FS' :: forall s. (s -> s -> s) -> (a -> s) -> s -> FS' a
[runFS'] :: FS' a -> forall s. (s -> s -> s) -> (a -> s) -> s

-- | A concatenated "triangle" of values:
--   
--   <pre>
--   saconcat [1] &lt;&gt; saconcat [1, 2] &lt;&gt; saconcat [1, 2, 3] &lt;&gt; .. &lt;&gt; saconcat [1..n]
--   </pre>
makeTriangle :: Semialternative f => Int -> f Int

-- | Conveniently construct and <a>Sum</a> a triangle of
--   <a>SemigroupFree</a> values for benchmarking.
destructTriangle :: SemigroupFree f => Proxy f -> Int -> Int

-- | A concatenated line of values
--   
--   <pre>
--   saconcat [1..n]
--   </pre>
makeLine :: Semialternative f => Int -> f Int

-- | Conveniently construct and <a>Sum</a> a line of <a>SemigroupFree</a>
--   values for benchmarking.
destructLine :: SemigroupFree f => Proxy f -> Int -> Int

-- | Apply <a>Int</a> to a type inside a <tt>proxy</tt>
proxyApInt :: proxy g -> Proxy (g Int)

-- | Benchmark <a>destructTriangle</a>
benchTriangle :: SemigroupFree f => Proxy f -> Int -> Benchmarkable

-- | Benchmark <a>destructLine</a>
benchLine :: SemigroupFree f => Proxy f -> Int -> Benchmarkable

-- | Weigh <a>destructTriangle</a>
weighTriangle :: SemigroupFree f => String -> Proxy f -> Int -> Weigh ()

-- | Weigh <a>destructLine</a>
weighLine :: SemigroupFree f => String -> Proxy f -> Int -> Weigh ()

-- | <a>weighTriangle</a> and <a>weighLine</a> for powers of <tt>2</tt> in
--   experimentally derived ranges.
weighPow2s :: SemigroupFree f => String -> Proxy f -> Weigh ()
type Est = Estimate ConfInt Double
reportEstimate :: Report -> Est
estimate :: Benchmarkable -> IO Est
quickEstimate :: Benchmarkable -> IO Est
quickConfig :: Config

-- | <a>benchTriangle</a> and <a>benchLine</a> for powers of <tt>2</tt> in
--   experimentally derived ranges.
benchPow2s :: SemigroupFree f => String -> Proxy f -> Benchmark

-- | <a>sequenceA</a> a benchmark over all of the <a>SemigroupFree</a>
--   implementations
benchable :: Applicative f => (forall g. SemigroupFree g => String -> Proxy g -> f a) -> f [a]
weighFS :: Weigh ()
runWeighFS :: IO ()
benchCompare :: Int -> (forall g. SemigroupFree g => Proxy g -> Benchmarkable) -> IO ()
benchFS :: [Benchmark]
runBenchFS :: IO ()
instance GHC.Base.Functor Data.Semigroup.Free.FS'
instance GHC.Base.Functor Data.Semigroup.Free.FS
instance GHC.Base.Functor Data.Semigroup.Free.FSemigroup
instance GHC.Base.Monad Data.Semigroup.Free.FPS
instance GHC.Base.Applicative Data.Semigroup.Free.FPS
instance GHC.Base.Functor Data.Semigroup.Free.FPS
instance GHC.Base.Monad Data.Semigroup.Free.FreePS
instance GHC.Base.Applicative Data.Semigroup.Free.FreePS
instance GHC.Base.Functor Data.Semigroup.Free.FreePS
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Free.FreePS a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Free.FreePS a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Free.FreePS a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Free.FreePS a)
instance GHC.Generics.Generic1 Data.Semigroup.Free.FreeSemigroup'
instance GHC.Generics.Generic (Data.Semigroup.Free.FreeSemigroup' a)
instance GHC.Base.Functor Data.Semigroup.Free.FreeSemigroup'
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Free.FreeSemigroup' a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Free.FreeSemigroup' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Free.FreeSemigroup' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Free.FreeSemigroup' a)
instance GHC.Generics.Generic1 Data.Semigroup.Free.FreeSemigroup
instance GHC.Generics.Generic (Data.Semigroup.Free.FreeSemigroup a)
instance GHC.Base.Functor Data.Semigroup.Free.FreeSemigroup
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Free.FreeSemigroup a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Free.FreeSemigroup a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Free.FreeSemigroup a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Free.FreeSemigroup a)
instance Control.Monad.Free.Class.MonadFree Data.Pair.Pair Data.Semigroup.Free.FreePS
instance Control.Monad.Free.Class.MonadFree Data.Pair.Pair Data.Semigroup.Free.FPS
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Free.FS' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Free.FS' a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Free.FS' a)
instance GHC.Base.Semigroup (Data.Semigroup.Free.FS' a)
instance GHC.Base.Applicative Data.Semigroup.Free.FS'
instance Data.Semigroup.Free.Semialternative Data.Semigroup.Free.FS'
instance Data.Semigroup.Free.SemigroupFree Data.Semigroup.Free.FS'
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Free.FS a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Free.FS a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Free.FS a)
instance GHC.Base.Semigroup (Data.Semigroup.Free.FS a)
instance GHC.Base.Applicative Data.Semigroup.Free.FS
instance Data.Semigroup.Free.Semialternative Data.Semigroup.Free.FS
instance Data.Semigroup.Free.SemigroupFree Data.Semigroup.Free.FS
instance Data.Semigroup.Free.SemigroupFree GHC.Base.NonEmpty
instance Data.Semigroup.Free.SemigroupFree Data.Semigroup.Free.FreeSemigroup
instance Data.Semigroup.Free.SemigroupFree Data.Semigroup.Free.FreeSemigroup'
instance Data.Semigroup.Free.SemigroupFree Data.Semigroup.Free.FreePS
instance Data.Semigroup.Free.SemigroupFree Data.Semigroup.Free.FPS
instance Data.Semigroup.Free.SemigroupFree Data.Semigroup.Free.FSemigroup
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Free.FSemigroup a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Free.FSemigroup a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Free.FSemigroup a)
instance GHC.Base.Semigroup (Data.Semigroup.Free.FSemigroup a)
instance GHC.Base.Applicative Data.Semigroup.Free.FSemigroup
instance Data.Semigroup.Free.Semialternative Data.Semigroup.Free.FSemigroup
instance Data.Semigroup.Free.Semialternative Data.Semigroup.Free.FPS
instance Data.Semigroup.Free.Semialternative Data.Semigroup.Free.FreePS
instance GHC.Base.Semigroup (Data.Semigroup.Free.FreeSemigroup' a)
instance GHC.Base.Applicative Data.Semigroup.Free.FreeSemigroup'
instance Data.Semigroup.Free.Semialternative Data.Semigroup.Free.FreeSemigroup'
instance GHC.Base.Semigroup (Data.Semigroup.Free.FreeSemigroup a)
instance GHC.Base.Applicative Data.Semigroup.Free.FreeSemigroup
instance Data.Semigroup.Free.Semialternative Data.Semigroup.Free.FreeSemigroup
instance Data.Semigroup.Free.Semialternative f => GHC.Base.Semigroup (Data.Semigroup.Free.WrapSemialternative f a)
instance Data.Semigroup.Free.Semialternative GHC.Base.NonEmpty

module Data.Sequence1

-- | A non-empty <a>Seq</a>, with a strict head and tail
data Seq1 a
Seq1 :: !a -> !(Seq a) -> Seq1 a
[seq1Head] :: Seq1 a -> !a
[seq1Tail] :: Seq1 a -> !(Seq a)

module Data.Tree.Utils

-- | Count the number of leaves of a tree
countLeaves :: Tree a -> Int

-- | Convert a non-empty path to a <a>Tree</a>
fromPath :: a -> [a] -> Tree a

-- | Convert a possibly-empty path to a <a>Forest</a>
fromPathF :: [a] -> Forest a

-- | The n-th triangular number: <tt>sum [1..n]</tt>
triangular :: Int -> Int
triangularR :: Int -> Int -> Int

-- | The forest of increasing first-occurrence partitions (beginning with
--   1) with the given length incParts numberOfDifferences seriesLength
--   seriesSum
incParts :: Int -> Int -> Int -> Forest Int

-- | The boundary series:
--   
--   <tt>z,z..z, x..y, z,z..z</tt> Length is <tt>n</tt>
--   
--   i before remainder after
--   
--   <pre>
--   [X,z,z,z,z,z,z]
--   [z,X,z,z,z,z,z]
--   [z,z,X,z,z,z,z]
--   [z,z,z,X,z,z,z]
--   </pre>
boundarySeries :: Int -> Int -> Int -> Int -> Forest Int
trimTree :: Tree (Maybe a) -> Maybe (Tree a)

-- | Trim a forest. See <a>trimTree</a>
trimForest :: Forest (Maybe a) -> Forest a

-- | <a>cycles</a> n m = All irreducible cycles of <tt>n</tt> elements of
--   length <tt>m</tt>
--   
--   A cycle <tt>cy</tt> is reducible iff there exists <tt>cy'</tt>, <tt>1
--   &lt; n</tt> such that:
--   
--   <pre>
--   replicate <tt>n</tt> cy' == cy
--   </pre>
cycles :: Int -> Int -> Forest Int

-- | <a>distinct0s</a> seems to have predictable polynomial lengths:
--   
--   Are these just (length <tt>choose</tt> number_of_0s)?
--   
--   位&gt; (n-&gt;mapM_ print$[getSum.foldMap(Sum. length.paths).distinct0s
--   i<a>$</a>[i+1..i+n]|i&lt;-[1..n]]) 12 [1,1,1,1,1,1,1,1,1,1,1,1]
--   [1,2,3,4,5,6,7,8,9,10,11,12] [1,3,6,10,15,21,28,36,45,55,66,78]
--   [1,4,10,20,35,56,84,120,165,220,286,364]
--   [1,5,15,35,70,126,210,330,495,715,1001,1365]
--   [1,6,21,56,126,252,462,792,1287,2002,3003,4368]
--   [1,7,28,84,210,462,924,1716,3003,5005,8008,12376]
--   [1,8,36,120,330,792,1716,3432,6435,11440,19448,31824]
--   [1,9,45,165,495,1287,3003,6435,12870,24310,43758,75582]
--   [1,10,55,220,715,2002,5005,11440,24310,48620,92378,167960]
--   [1,11,66,286,1001,3003,8008,19448,43758,92378,184756,352716]
--   [1,12,78,364,1365,4368,12376,31824,75582,167960,352716,705432] (41.30
--   secs, 21,512,577,928 bytes)
--   
--   ((n ==) . count (0 ==)) <a>filter</a> distincts 2 m == distinct0s n m
--   distinct0s numberOfZeroes seriesLength
distinct0s :: Int -> Int -> Forest Int

-- | <tt>distincts n m =</tt> the <a>Tree</a> of series of length
--   <tt>m</tt> with <tt>n</tt> distinct elements (<tt>[0..n-1]</tt>)
distincts :: Int -> Int -> Forest Int

-- | <tt>series n m =</tt> the <a>Tree</a> of series of length <tt>m</tt>
--   with up to <tt>n</tt> distinct elements (<tt>[0..n-1]</tt>)
series :: Int -> Int -> Forest Int

-- | All paths in a <a>Tree</a>
paths :: Tree a -> [[a]]

-- | Given a way to convert an initial value to a state, a way to update
--   the state with the new value, and a way to extract a result of whether
--   to keep or not to keep the resulting series, filter a <a>Tree</a>
stepFilter :: (a -> b) -> (a -> b -> b) -> (b -> Bool) -> Tree a -> Maybe (Tree a)

-- | Step-fiter a <a>Tree</a>, given an initial state
stepFilter1 :: (a -> b -> b) -> (b -> Bool) -> b -> Tree a -> Maybe (Tree a)

-- | Step-fiter a piece-wise <a>Tree</a>, given an initial state
stepFilterWith :: (a -> b -> b) -> (b -> Bool) -> b -> a -> Forest a -> Maybe (Tree a)

-- | Step-fiter a <a>Forest</a>, given an initial state function
stepFilters :: (a -> b) -> (a -> b -> b) -> (b -> Bool) -> Forest a -> Forest a

-- | Step-fiter a <a>Forest</a>, given an initial state
stepFilters1 :: (a -> b -> b) -> (b -> Bool) -> b -> Forest a -> Forest a

-- | Map over all sub-<a>Forest</a>s in a <a>Tree</a>
mapsTree :: (Forest a -> Forest a) -> Tree a -> Tree a

-- | Replace each node in a tree with the the <a>NonEmpty</a> list
--   consisting of the original node, followed by the first path after that
--   node.
--   
--   When using <a>drawTree</a> or <a>drawTreeU</a>, this can be used to
--   compress the representation, especially when there is little
--   branching.
firstForest :: Tree a -> Tree (NonEmpty a)

-- | A <a>Forest</a> of all series with elements in <tt>1..input</tt>
fseries :: Enum a => a -> Forest a

-- | Scan along a <a>Tree</a> with a stepper and converter
stepTree :: (a -> b -> b) -> (a -> b) -> Tree a -> Tree b

-- | Scan along a <a>Tree</a> with a stepper, converter, and initial scan
--   state
stepTree1 :: (a -> b -> b) -> (a -> b) -> b -> Tree a -> Tree b

-- | Scan along a <a>Forest</a> with a stepper, converter, and initial scan
--   state
stepForest :: (a -> b -> b) -> (a -> b) -> b -> Forest a -> Forest b

-- | <a>stepTree</a>, returning a list of successive states
stepTreeList :: (a -> b -> b) -> (a -> b) -> Tree a -> Tree ([a], b)

-- | Scan along a <a>Tree</a> with a stepper, converter, and initial scan
--   state
stepTreeList1 :: (a -> b -> b) -> (a -> b) -> b -> Tree a -> Tree ([a], b)

-- | Scan along a <a>Forest</a> with a stepper, converter, and initial scan
--   state
stepForestList :: (a -> b -> b) -> (a -> b) -> b -> Forest a -> Forest ([a], b)

-- | Equivalent to:
--   
--   <pre>
--   unzip . map ((Node x xs) -&gt; (x, xs))
--   </pre>
unzipForest :: Forest a -> ([a], [Forest a])

-- | Take up to the given depth
takeDepth :: Int -> Tree a -> Tree a

-- | Take up to the given depth
takeDepths :: Int -> Forest a -> Forest a

-- | Maximum of a tree, using a comparison function
maxTreeOn_ :: Ord b => (a -> b) -> Tree a -> [a]

-- | The maximum of a forest on a given value, returning that value.
--   
--   This implementation assumes that computing the given function is
--   expensive and only computes it once.
maxForestOn :: Ord b => (a -> b) -> Forest a -> Tree (b, a)

-- | The maximum of a forest on a given value.
--   
--   This implementation assumes that computing the given function is
--   cheap.
maxForestOn_ :: Ord b => (a -> b) -> Forest a -> Tree a

-- | From: <a>https://github.com/haskell/containers/pull/344/files</a>
--   
--   Neat 2-dimensional drawing of a tree. Unicode paths
drawTreeU :: Tree String -> String

-- | More compact <a>drawTreeU</a>
drawTreeU' :: Tree String -> String

-- | Neat 2-dimensional drawing of a forest. Unicode paths
drawForestU :: Forest String -> String

-- | Draw a tree with spaces
drawU :: Tree String -> [String]

-- | Draw a tree with unicode
drawU' :: Tree String -> [String]
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Tree.Tree a)

module Data.IntPosMap
maxDiffSeries :: [Int]

-- | Scan, stepping an <a>IntPosMap</a> along a non-empty list
scanIntPosMap :: Enum a => [a] -> [IntPosMap]

-- | also return current list
scanIntPosMapL :: Enum a => [a] -> [([a], IntPosMap)]

-- | The depths of a list as it cycles, after an initial non-cycling
--   section
intPosMapThenCycles :: [Int] -> [Int] -> [Int]

-- | The depths of a list as it cycles
intPosMapCycles :: [Int] -> [Int]

-- | Only output depths of full cycles
intPosMapFullCycles :: [Int] -> [Int]
distinctDepths :: Int -> Int -> IntMap Int
distinctDepths' :: Int -> Int -> IntMap Int
distinctKeyDepths :: Int -> Int -> Map (IntMap Int) Int
distinct0Depths :: Int -> Int -> IntMap Int
d0d2s_0 :: Int -> [Int]
d0d2s_0_18 :: [Int]
d0d2fs_0 :: Int -> [Int]
prop_d0d2s_0 :: Bool
d0d3s_0 :: Int -> [Int]
d0d3s_0_22 :: [Int]
d0d3fs_0 :: Int -> [Int]
prop_d0d3s_0 :: Bool
d0d3s_1 :: Int -> [Int]
d0d3s_1_21 :: [Int]
d0d3fs_1 :: Int -> [Int]
prop_d0d3s_1 :: Bool
d0d4s_0 :: Int -> [Int]
d0d4s_0_21 :: [Int]
d0d4fs_0 :: Int -> [Int]
prop_d0d4s_0 :: Bool
d0d4s_1 :: Int -> [Int]
d0d4s_1_20 :: [Int]
d0d4fs_1 :: Int -> [Int]
prop_d0d4s_1 :: Bool
d0d4s_2 :: Int -> [Int]
d0d4s_2_30 :: [Int]
d0d4fs_2 :: Int -> [Int]
prop_d0d4s_2 :: Bool
d0d5s_0 :: Int -> [Int]
d0d5s_0_20 :: [Int]
d0d5fs_0 :: Int -> [Int]
prop_d0d5s_0 :: Bool
d0d5s_1 :: Int -> [Int]
d0d5s_0_30 :: [Int]
d0d5s_2 :: Int -> [Int]
d0d5IO :: IO ()
d0d6IO :: IO ()
d0d5s :: [[Int]]
printDistinct0Depths :: Int -> IO ()

-- | All the counts of depthds for 2 distinct elements of lengths [0..]
distinctDepths2 :: IO ()

-- | Output from <a>distinctDepths2</a>
dd2 :: [[Int]]

-- | All <a>distincts</a> whose resulting <a>IntPosMap</a> is of the given
--   depth
ofDepth :: Int -> Int -> Int -> Forest Int

-- | <tt>PosMap</tt> specified to <a>Int</a> so that <a>IntMap</a> may be
--   used.
data IntPosMap
IntPosMap :: IntMap PosCxt -> !Int -> IntPosMap
[getIntPosMap] :: IntPosMap -> IntMap PosCxt
[intPosMapLen] :: IntPosMap -> !Int
maxDepthRuns :: Int -> IO ()

-- | Tally all max depths and return <tt>[(length, tally (maxDepths at
--   level of fseries))]</tt>
tallyMaxDepths :: Int -> [(Int, IntMap Int)]
tallyMaxDepthSums :: Int -> [(Int, [Int])]

-- | C505837424
--   
--   stack exec -- basic-exe 25900.09s user 5447.72s system 139% cpu
--   6:15:27.65 total
baseDepths :: Int -> Int -> [([Int], Int)]
assertEqualUptoPerms2 :: Int -> Bool

-- | toBase is an inverse of fromBase: 位&gt; (n-&gt;all ((<a>all</a>
--   [0..n]) . liftM2(==)id.liftM2(.)fromBase(flip toBase))[2..n]) 1000
--   True (5.28 secs, 1,521,236,536 bytes)
--   
--   tallyMaxDepthSums 2
ee' :: [(Int, [Int])]

-- | tallyMaxDepthSums 3
ee3' :: [(Int, [Int])]
ee :: [[Int]]
ee3 :: [[Int]]
ff :: [[Int]]
ff3 :: [[Int]]
tt :: Int -> Int -> [[Int]]
checkAllsecondDiffsDivPredN :: Int -> Int -> [Bool]
middle1d :: Int -> Int -> Int
middle1ds :: Int -> Int -> (Int, Int)
middle1dKeys :: Int -> Int -> IntMap Int
checkAllTallySumsDivisibleByN :: Int -> [(Int, Bool)]
maxDepthForBools :: Pair [(Int, (Int, IntPosMap))]

-- | Print all of the maximum depths of <a>IntPosMap</a>'s with examples
ppMaxDepthForBools :: IO ()

-- | The depth of an <a>IntPosMap</a>, i.e. how many times we recurse in a
--   particular <a>IntPosMap</a>
intPosMapDepth :: IntPosMap -> Int
intPosMapDepths :: IntPosMap -> Maxes Int
intPosMapKeyDepths :: IntPosMap -> IntMap Int

-- | The max depth tree of an <a>IntPosMap</a> for the given number of
--   elements
maxDepthForN :: Int -> Tree (Int, [Int])

-- | Show by converting maps to <tt>{k1 =&gt; x1, k2 =&gt; x2, ..}</tt>
ppIntPosMap :: IntPosMap -> String

-- | Show using <a>drawForest</a> after converting to a <a>Forest</a>
ppIntPosMap' :: IntPosMap -> String

-- | <a>ppIntPosMap</a> for the element at <tt>0</tt>
ppIntPosMap0 :: IntPosMap -> String

-- | <a>ppIntPosMap</a> for the element at <tt>1</tt>
ppIntPosMap1 :: IntPosMap -> String

-- | Tree context for an <a>IntPosMap</a>.
--   
--   <pre>
--   (val, firstIx, lastIx, len, Maybe diff)
--   </pre>
--   
--   See <a>intPosMapToForest</a>
type Tcxt = (Int, Int, Int, Int, Maybe Int)

-- | Convert to a <a>Forest</a> for easier analysis
intPosMapToForest :: IntPosMap -> Forest Tcxt

-- | Pretty-print an <a>IntMap</a> using an explicit <a>show</a> method
ppIntMap :: (a -> String) -> IntMap a -> String

-- | A <a>IntPosMap</a> containing a single element
pureIntPosMap :: Int -> IntPosMap

-- | Map over the top layer of keys in a <tt>PosMap</tt>
mapIntPosMap :: (Int -> Int) -> IntPosMap -> IntPosMap

-- | Map over the top layer of keys monotonically in a <a>IntPosMap</a>
mapIntPosMapMonotonic :: (Int -> Int) -> IntPosMap -> IntPosMap

-- | See <tt>fromPosMap</tt>
fromIntPosMap :: IntPosMap -> NonEmpty Int

-- | Convert any non-empty <a>Foldable</a> to <a>Just</a> a
--   <a>IntPosMap</a> by applying <a>stepIntPosMap</a> to
--   <a>pureIntPosMap</a> and then each successive element, or any empty
--   <a>Foldable</a> to <a>Nothing</a>.
toIntPosMap :: Foldable t => t Int -> Maybe IntPosMap

-- | <a>toIntPosMap</a>, but throw an error instead of returning
--   <a>Nothing</a>
toIntPosMap' :: Foldable t => t Int -> IntPosMap

-- | Add an element to a <a>IntPosMap</a> by incrementing its length and
--   <a>upsert</a>ing the element and position.
stepIntPosMap :: Int -> IntPosMap -> IntPosMap

-- | The position context of an element, containing its first index
--   (offset), last index (for convenience), length (size), and
--   <a>Either</a> <a>Right</a> a recursive <a>IntPosMap</a> to store
--   series more complex than a single-element cycle or <a>Left</a> to
--   indicate that it's a single-element cycle of that period (difference).
--   
--   <tt>maxIx :: Int</tt> using <tt>maxIx</tt> instead of length allows us
--   to quickly read off the index when adding values.. but if we're
--   updating it anyway, we could use the old length as the new
--   <tt>maxIx</tt>..
data PosCxt
PosCxt :: !Int -> !Int -> !Int -> !(Either Int IntPosMap) -> PosCxt
[firstIx] :: PosCxt -> !Int
[lastIx] :: PosCxt -> !Int
[posCxtLen] :: PosCxt -> !Int

-- | <tt><a>Left</a> x</tt> for all <tt>x</tt>'s
[ixSeries] :: PosCxt -> !(Either Int IntPosMap)

-- | The depth of an <a>PosCxt</a>, i.e. how many times we recurse in a
--   particular <a>PosCxt</a>
posCxtDepth :: PosCxt -> Int

-- | Convert to a <a>Tree</a> for easier analysis
posCxtToTree :: Int -> PosCxt -> Tree Tcxt

-- | <a>Left</a> to <a>Just</a>
leftToMaybe :: Either a b -> Maybe a

-- | <a>Right</a> to `[x]`
rightToList :: Either a b -> [b]

-- | Pretty-print a <a>PosCxt</a>
ppPosCxt :: PosCxt -> String

-- | A <a>PosCxt</a> for a single repetition of an element at the given
--   index.
purePosCxt :: Int -> PosCxt

-- | Just added the case for 0, should refactor as needed lated (e.g. could
--   check that it's a singleton earlier)
--   
--   Add an element index to a <a>PosCxt</a>.
--   
--   We increment the size and calculate the next decremented difference:
--   <tt>(newIx - lastIx) - 1</tt>.
--   
--   If the <tt>isSeries</tt> is <a>Nothing</a> (i.e. representing a
--   single-element cycle), then we check whether it's continued (in which
--   case we return <a>Nothing</a>) or we need to make a new
--   <a>IntPosMap</a> to represent the series.
stepPosCxt :: Int -> PosCxt -> PosCxt

-- | Convert any non-empty <a>Foldable</a> to a <a>PosCxt</a> by applying
--   <tt>stepPosMap</tt> to <a>purePosCxt</a> and then each successive
--   element.
toPosCxt :: Foldable t => t Int -> Maybe PosCxt

-- | List, incl. offset, of whether or not the value of a <a>PosCxt</a> is
--   currently at that index.
--   
--   For example, for the <a>PosCxt</a> of <tt>1</tt> in
--   <tt>[0,1,1,0,0,1]</tt> <a>posCxtToBools</a> would be:
--   
--   <pre>
--   [False, True, True, False, False, True]
--   </pre>
posCxtToBools :: PosCxt -> [Bool]

-- | Convert a <a>PosCxt</a> to a list of indices (positions) of its
--   associated element.
posCxtIndices :: PosCxt -> [Int]
type Gapped = MaybeT

-- | If <a>True</a> then return the value, else <a>Nothing</a>.
maybeIf :: a -> Bool -> Maybe a

-- | Convert a value and a its <a>PosCxt</a> to a list of of <a>Just</a>
--   the value where it occurs in the list and <a>Nothing</a> (or the list
--   ends) otherwise.
--   
--   Every <a>Nothing</a> preceeds some <a>Just</a>. If there are no more
--   <a>Just</a>'s, the output ends.
posCxtToGapped :: a -> PosCxt -> Gapped [] a

-- | <a>quickCheckAll</a>
runTests :: IO Bool
instance GHC.Generics.Generic Data.IntPosMap.IntPosMap
instance Control.DeepSeq.NFData Data.IntPosMap.IntPosMap
instance Data.Data.Data Data.IntPosMap.IntPosMap
instance GHC.Read.Read Data.IntPosMap.IntPosMap
instance GHC.Show.Show Data.IntPosMap.IntPosMap
instance GHC.Classes.Ord Data.IntPosMap.IntPosMap
instance GHC.Classes.Eq Data.IntPosMap.IntPosMap
instance GHC.Generics.Generic Data.IntPosMap.PosCxt
instance Control.DeepSeq.NFData Data.IntPosMap.PosCxt
instance Data.Data.Data Data.IntPosMap.PosCxt
instance GHC.Show.Show Data.IntPosMap.PosCxt
instance GHC.Read.Read Data.IntPosMap.PosCxt
instance GHC.Classes.Ord Data.IntPosMap.PosCxt
instance GHC.Classes.Eq Data.IntPosMap.PosCxt
instance GHC.Base.Semigroup Data.IntPosMap.IntPosMap
instance GHC.Exts.IsList Data.IntPosMap.IntPosMap
instance GHC.Base.Semigroup Data.IntPosMap.PosCxt
instance GHC.Exts.IsList Data.IntPosMap.PosCxt

module Data.PosMap

-- | Todo:
--   
--   <pre>
--   TODO:
--   - Cycle extraction
--   - Cycle-finding: extractCycle . toPosMap :: (Foldable t, Ord a) =&gt; t a -&gt; Maybe (Cycle a) -- Cycle a = NonEmpty a
--   - Testing: vs naive implementation, testing bijections, etc.
--   - Benchmarking: compare to naive, known algorithms. See: <a>https://en.wikipedia.org/wiki/Cycle_detection</a>
--   - Add obvious ways of parallelizing the algorithms
--   </pre>
todo :: ()

-- | Note:
--   
--   <pre>
--   One of the main attractions of this algorithm is that it's clearly in map-reduce form:
--     Convert all partitions of the series to <a>PosMap</a>'s or <a>IntPosMap</a>'s (set-parallel)
--     Combine in parallel (ordered-tree-parallel) (See <a>Semigroup</a> instances)
--     Consume in parallel (ordered-tree-parallel) (See conversion to <a>NonEmpty</a>, <tt>Seq</tt>, <tt>Cycle</tt>)
--   
--   Where:
--     set-parallel: Structurally equivalent to mapping over a set with no hidden dependencies
--     ordered-tree-parallel: Structurally equivalent to evaluating an ordered tree with no hidden dependencies (e.g. a rose tree: <tt>Tree</tt>)
--   
--   start with a single value, providing a one-layer cycle-decomposition:
--     [x]
--     { x =&gt; (0, 0, 0, Cycled 1) }
--   
--   if we add an equal value, we get:
--     [x,x]
--     { x =&gt; (0, 1, 1, Cycled 2) }
--   
--   if we add an unequal value, we get:
--   
--   t=[x, y]
--   t={ x =&gt; (0, 0, 0, Cycled 1)
--     , y =&gt; (1, 1, 0, Cycled 1)
--     }
--   
--   t=[x, x, y]
--   t={ x =&gt; (0, 1, 1, Cycled 2)
--     , y =&gt; (2, 2, 0, Cycled 1)
--     }
--   
--   t=[x, x, y, y]
--   t={ x =&gt; (0, 1, 1, Cycled 2)
--     , y =&gt; (2, 3, 1, Cycled 2)
--     }
--   
--   t=[x, x, y, y, x]
--   t={ x =&gt; (0, 1, 2, { 0 =&gt; (0, 1, 1, Cycled 2), 2 =&gt; (2, 2, 0, Cycled 1) } )
--     , y =&gt; (2, 3, 1, Cycled 2)
--     }
--   
--   t=[x, x, y, y, x, x]
--   t={ x =&gt; (0, 5, 3, { 0 =&gt; (0, 3, 3, { 0 =&gt; (0, 1, 1, Cycled 2), 1 =&gt; (3, 3, 0, Cycled 1)}), 2 =&gt; (2, 2, Cycled 1) } )
--     , y =&gt; (2, 3, 1, Cycled 2)
--     }
--   
--   t=[x, x, y, y, x, x, y]
--   t={ x =&gt; (0, 5, 3, { 0 =&gt; (0, 3, 3, { 0 =&gt; (0, 1, 1, Cycled 2), 1 =&gt; (3, 3, 0, Cycled 1)}), 2 =&gt; (2, 2, Cycled 1) } )
--     , y =&gt; (2, 3, 1, { 0 =&gt; (2, 3, 1, Cycled 2), 2 =&gt; (6, 6, 0, Cycled 1)})
--     }
--   
--   Map a (first index, last index, size - 1, Cycled size | IntMap (...)
--   
--   - We omit the value inside <tt>Cycled</tt> since it's already in the <a>PosCxt</a>
--   - We implement <tt>Cycled  | _</tt> as <a>Maybe</a>
--   
--   Diffs are actually (x - y - 1), this makes the minimum key of each intermal map 0 instead of 1.
--   
--   Cycled i = replicate i 0
--   </pre>
note :: ()

-- | To extract a cycle, we get the largest final cycles from each of the
--   subexpressions. We then combine the cycles (that include beginning
--   indices, etc.)
data PosMap (a :: *)
PosMap :: Map a PosCxt -> !Int -> PosMap
[getPosMap] :: PosMap -> Map a PosCxt
[posMapLen] :: PosMap -> !Int

-- | A <a>PosMap</a> containing a single element
purePosMap :: a -> PosMap a

-- | Map over the top layer of keys in a <a>PosMap</a>
mapPosMap :: Ord b => (a -> b) -> PosMap a -> PosMap b

-- | Map over the top layer of keys monotonically in a <a>PosMap</a>
mapPosMapMonotonic :: (a -> a) -> PosMap a -> PosMap a

-- | The idea is that we convert each value's <a>PosCxt</a> to a list of
--   <a>Bool</a>'s, where an element is <a>True</a> iff the element in the
--   original list is equal to the given value.
--   
--   We convert <a>True</a> to the value, <a>False</a> to <a>Nothing</a>,
--   then we combine the lists by zipping together the <a>Maybe</a>'s with
--   <tt>(<a>&lt;|&gt;</a>)</tt>.
--   
--   Since, for a <a>PosMap</a> to be valid all elements must be accounted
--   for, we know that all of the elements in the resulting list must be
--   <a>Just</a>.
fromPosMap :: PosMap a -> NonEmpty a

-- | Convert any non-empty <a>Foldable</a> to a <a>PosMap</a> by applying
--   <a>stepPosMap</a> to <a>purePosMap</a> and then each successive
--   element.
toPosMap :: (Foldable t, Ord a) => t a -> Maybe (PosMap a)

-- | Add an element to a <a>PosMap</a> by incrementing its length and
--   <a>upsert</a>ing the element and position.
stepPosMap :: Ord a => a -> PosMap a -> PosMap a

-- | Convert a <a>PosMap</a> to an <a>IntPosMap</a>
posMapToIntPosMap :: Enum a => PosMap a -> IntPosMap

-- | Convert an <a>IntPosMap</a> to a <a>PosMap</a>
intPosMapToPosMap :: Enum a => IntPosMap -> PosMap a
instance GHC.Generics.Generic (Data.PosMap.PosMap a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.PosMap.PosMap a)
instance (Data.Data.Data a, GHC.Classes.Ord a) => Data.Data.Data (Data.PosMap.PosMap a)
instance (GHC.Classes.Ord a, GHC.Read.Read a) => GHC.Read.Read (Data.PosMap.PosMap a)
instance GHC.Show.Show a => GHC.Show.Show (Data.PosMap.PosMap a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.PosMap.PosMap a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.PosMap.PosMap a)
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.PosMap.PosMap a)
instance GHC.Classes.Ord a => GHC.Exts.IsList (Data.PosMap.PosMap a)
instance Data.Foldable.Foldable Data.PosMap.PosMap
